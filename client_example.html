<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SFU WebRTC Client Example</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .container { max-width: 800px; margin: 0 auto; }
        .participant { margin: 10px 0; padding: 10px; border: 1px solid #ccc; }
        .controls { margin: 20px 0; }
        button { margin: 5px; padding: 10px; }
        #status { background: #f0f0f0; padding: 10px; margin: 10px 0; }
        audio { width: 100%; margin: 5px 0; }
    </style>
</head>
<body>
    <div class="container">
        <h1>SFU WebRTC Meeting Client</h1>
        
        <div class="controls">
            <input type="text" id="roomId" placeholder="Room ID" value="test-room">
            <input type="text" id="participantId" placeholder="Your Name" value="">
            <button onclick="testMicrophone()">Test Microphone</button>
            <button onclick="joinRoom()">Join Room</button>
            <button onclick="leaveRoom()">Leave Room</button>
        </div>
        
        <div class="controls">
            <button onclick="toggleMute()">Toggle Mute</button>
            <button onclick="getRoomStats()">Get Room Stats</button>
        </div>
        
        <div id="status">Not connected</div>
        
        <div id="localAudio">
            <h3>Your Audio</h3>
            <audio id="localAudioElement" controls muted></audio>
        </div>
        
        <div id="remoteParticipants">
            <h3>Other Participants</h3>
        </div>
        
        <div id="logs">
            <h3>Logs</h3>
            <div id="logContainer" style="height: 200px; overflow-y: scroll; background: #f9f9f9; padding: 10px;"></div>
        </div>
    </div>

    <script>
        class SFUClient {
            constructor() {
                this.websocket = null;
                this.localStream = null;
                this.peerConnections = new Map(); // participant_id -> RTCPeerConnection
                this.remoteStreams = new Map(); // participant_id -> MediaStream
                this.roomId = null;
                this.participantId = null;
                this.isMuted = false;
                
                // WebRTC configuration
                this.rtcConfig = {
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' }
                    ]
                };
            }
            
            async joinRoom(roomId, participantId) {
                this.roomId = roomId;
                this.participantId = participantId || `user_${Math.random().toString(36).substr(2, 9)}`;
                
                try {
                    this.log('Requesting microphone permission...');
                    this.updateStatus('Requesting microphone access...');
                    
                    // Get user media first
                    this.localStream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            echoCancellation: true,
                            noiseSuppression: true,
                            autoGainControl: true
                        },
                        video: false
                    });
                    
                    this.log('Microphone access granted');
                    this.updateStatus('Microphone ready, connecting...');
                    
                    // Display local audio (muted to prevent feedback)
                    const localAudio = document.getElementById('localAudioElement');
                    localAudio.srcObject = this.localStream;
                    localAudio.muted = true;  // Prevent audio feedback from your own microphone
                    localAudio.volume = 0;    // Ensure no local playback
                    
                    // Connect to WebSocket signaling server  
                    // Handle ngrok HTTPS properly
                    let wsUrl;
                    if (window.location.hostname.includes('ngrok')) {
                        // For ngrok, use the same host but with wss protocol
                        wsUrl = `wss://${window.location.host}/api/v1/ws?room_id=${roomId}&participant_id=${this.participantId}`;
                    } else {
                        // For local or direct IP access
                        const serverIP = window.location.hostname === 'localhost' ? 'localhost' : '10.20.94.242';
                        const protocol = window.location.protocol === 'https:' ? 'wss' : 'ws';
                        wsUrl = `${protocol}://${serverIP}:8000/api/v1/ws?room_id=${roomId}&participant_id=${this.participantId}`;
                    }
                    
                    this.log(`Connecting to: ${wsUrl}`);
                    this.websocket = new WebSocket(wsUrl);
                    
                    this.websocket.onopen = () => {
                        this.log('Connected to SFU server');
                        this.updateStatus('Connected to room: ' + roomId);
                    };
                    
                    this.websocket.onmessage = (event) => {
                        const message = JSON.parse(event.data);
                        this.handleSignalingMessage(message);
                    };
                    
                    this.websocket.onclose = () => {
                        this.log('Disconnected from SFU server');
                        this.updateStatus('Disconnected');
                    };
                    
                    this.websocket.onerror = (error) => {
                        this.log('WebSocket error: ' + error);
                    };
                    
                } catch (error) {
                    if (error.name === 'NotAllowedError') {
                        this.log('Microphone permission denied. Please allow microphone access and try again.');
                        this.updateStatus('Microphone permission denied');
                        alert('Please allow microphone access to join the meeting. Click the microphone icon in your browser\'s address bar and refresh the page.');
                    } else if (error.name === 'NotFoundError') {
                        this.log('No microphone found. Please connect a microphone and try again.');
                        this.updateStatus('No microphone found');
                    } else {
                        this.log('Error joining room: ' + error.name + ' - ' + error.message);
                        this.updateStatus('Connection error: ' + error.name);
                    }
                }
            }
            
            async handleSignalingMessage(message) {
                this.log('Received: ' + message.type);
                
                switch (message.type) {
                    case 'room-info':
                        await this.handleRoomInfo(message);
                        break;
                        
                    case 'status':
                        this.log(`Room status: ${message.message}`);
                        break;
                        
                    case 'error':
                        this.log(`Server error: ${message.message}`);
                        this.updateStatus('Server error: ' + message.message);
                        break;
                        
                    case 'stream-available':
                        await this.handleNewStream(message);
                        break;
                        
                    case 'offer':
                        await this.handleOffer(message);
                        break;
                        
                    case 'answer':
                        await this.handleAnswer(message);
                        break;
                        
                    case 'ice-candidate':
                        await this.handleIceCandidate(message);
                        break;
                        
                    case 'participant_muted':
                    case 'participant_unmuted':
                        this.log(`Participant ${message.participant_id} ${message.type.split('_')[1]}`);
                        break;
                        
                    case 'room-stats':
                        this.displayRoomStats(message.data);
                        break;
                        
                    case 'pong':
                        // Heartbeat response
                        break;
                        
                    default:
                        this.log('Unknown message type: ' + message.type);
                }
            }
            
            async handleRoomInfo(message) {
                this.log(`Room info: ${message.participants.length} participants`);
                
                // Announce our stream to the room
                if (this.localStream) {
                    const audioTrack = this.localStream.getAudioTracks()[0];
                    if (audioTrack) {
                        this.sendSignalingMessage({
                            type: 'stream-added',
                            stream_id: audioTrack.id,
                            stream_type: 'audio'
                        });
                    }
                }
                
                // Request to subscribe to existing streams
                for (const stream of message.available_streams) {
                    await this.subscribeToStream(stream.participant_id, stream.stream_id);
                }
            }
            
            async handleNewStream(message) {
                this.log(`New stream available from ${message.stream_owner_id}`);
                await this.subscribeToStream(message.stream_owner_id, message.stream_id);
            }
            
            async subscribeToStream(participantId, streamId) {
                // Create peer connection if it doesn't exist
                if (!this.peerConnections.has(participantId)) {
                    await this.createPeerConnection(participantId);
                }
                
                // Send subscription request
                this.sendSignalingMessage({
                    type: 'subscribe-to-stream',
                    stream_owner_id: participantId,
                    stream_id: streamId
                });
                
                // Create offer to establish connection
                const pc = this.peerConnections.get(participantId);
                
                // Add our local stream to the peer connection
                if (this.localStream) {
                    for (const track of this.localStream.getTracks()) {
                        pc.addTrack(track, this.localStream);
                    }
                }
                
                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);
                
                this.sendSignalingMessage({
                    type: 'offer',
                    target_participant_id: participantId,
                    sdp: offer.sdp,
                    sdp_type: offer.type
                });
            }
            
            async createPeerConnection(participantId) {
                const pc = new RTCPeerConnection(this.rtcConfig);
                this.peerConnections.set(participantId, pc);
                
                // Handle incoming streams
                pc.ontrack = (event) => {
                    this.log(`Received stream from ${participantId}`);
                    const remoteStream = event.streams[0];
                    this.remoteStreams.set(participantId, remoteStream);
                    this.displayRemoteStream(participantId, remoteStream);
                };
                
                // Handle ICE candidates
                pc.onicecandidate = (event) => {
                    if (event.candidate) {
                        this.sendSignalingMessage({
                            type: 'ice-candidate',
                            target_participant_id: participantId,
                            candidate: event.candidate.candidate,
                            sdpMid: event.candidate.sdpMid,
                            sdpMLineIndex: event.candidate.sdpMLineIndex
                        });
                    }
                };
                
                pc.onconnectionstatechange = () => {
                    this.log(`Connection with ${participantId}: ${pc.connectionState}`);
                };
            }
            
            async handleOffer(message) {
                const participantId = message.from_participant_id;
                
                if (!this.peerConnections.has(participantId)) {
                    await this.createPeerConnection(participantId);
                }
                
                const pc = this.peerConnections.get(participantId);
                
                await pc.setRemoteDescription({
                    type: message.sdp_type,
                    sdp: message.sdp
                });
                
                // Add our local stream
                if (this.localStream) {
                    for (const track of this.localStream.getTracks()) {
                        pc.addTrack(track, this.localStream);
                    }
                }
                
                const answer = await pc.createAnswer();
                await pc.setLocalDescription(answer);
                
                this.sendSignalingMessage({
                    type: 'answer',
                    target_participant_id: participantId,
                    sdp: answer.sdp,
                    sdp_type: answer.type
                });
            }
            
            async handleAnswer(message) {
                const participantId = message.from_participant_id;
                const pc = this.peerConnections.get(participantId);
                
                if (pc) {
                    await pc.setRemoteDescription({
                        type: message.sdp_type,
                        sdp: message.sdp
                    });
                }
            }
            
            async handleIceCandidate(message) {
                const participantId = message.from_participant_id;
                const pc = this.peerConnections.get(participantId);
                
                if (pc) {
                    await pc.addIceCandidate({
                        candidate: message.candidate,
                        sdpMid: message.sdpMid,
                        sdpMLineIndex: message.sdpMLineIndex
                    });
                }
            }
            
            displayRemoteStream(participantId, stream) {
                const container = document.getElementById('remoteParticipants');
                
                // Remove existing audio element if it exists
                const existingAudio = document.getElementById(`audio_${participantId}`);
                if (existingAudio) {
                    existingAudio.remove();
                }
                
                // Create new audio element for remote participant
                const audioElement = document.createElement('audio');
                audioElement.id = `audio_${participantId}`;
                audioElement.srcObject = stream;
                audioElement.autoplay = true;  // This is key - must autoplay for remote audio
                audioElement.controls = true;
                audioElement.volume = 1.0;     // Ensure full volume
                audioElement.muted = false;    // Make sure it's not muted
                
                // Force audio to play (some browsers require user interaction)
                audioElement.play().catch(e => {
                    this.log(`Audio autoplay blocked for ${participantId}. Click the play button.`);
                });
                
                const participantDiv = document.createElement('div');
                participantDiv.className = 'participant';
                participantDiv.innerHTML = `<h4>ðŸ”Š ${participantId}</h4>`;
                participantDiv.appendChild(audioElement);
                
                container.appendChild(participantDiv);
                
                this.log(`Audio element created for ${participantId} - should be playing automatically`);
            }
            
            sendSignalingMessage(message) {
                if (this.websocket && this.websocket.readyState === WebSocket.OPEN) {
                    this.websocket.send(JSON.stringify(message));
                    this.log('Sent: ' + message.type);
                }
            }
            
            toggleMute() {
                if (this.localStream) {
                    const audioTrack = this.localStream.getAudioTracks()[0];
                    if (audioTrack) {
                        audioTrack.enabled = !audioTrack.enabled;
                        this.isMuted = !audioTrack.enabled;
                        
                        this.sendSignalingMessage({
                            type: this.isMuted ? 'mute' : 'unmute'
                        });
                        
                        this.log(this.isMuted ? 'Muted' : 'Unmuted');
                    }
                }
            }
            
            getRoomStats() {
                this.sendSignalingMessage({
                    type: 'get-room-stats'
                });
            }
            
            displayRoomStats(stats) {
                this.log(`Room Stats - Participants: ${stats.participants}, Active Streams: ${stats.active_streams}`);
            }
            
            leaveRoom() {
                if (this.websocket) {
                    this.websocket.close();
                }
                
                // Close all peer connections
                for (const pc of this.peerConnections.values()) {
                    pc.close();
                }
                this.peerConnections.clear();
                this.remoteStreams.clear();
                
                // Stop local stream
                if (this.localStream) {
                    this.localStream.getTracks().forEach(track => track.stop());
                    this.localStream = null;
                }
                
                // Clear UI
                document.getElementById('remoteParticipants').innerHTML = '<h3>Other Participants</h3>';
                document.getElementById('localAudioElement').srcObject = null;
                
                this.updateStatus('Not connected');
                this.log('Left room');
            }
            
            log(message) {
                const logContainer = document.getElementById('logContainer');
                const timestamp = new Date().toLocaleTimeString();
                logContainer.innerHTML += `<div>[${timestamp}] ${message}</div>`;
                logContainer.scrollTop = logContainer.scrollHeight;
            }
            
            updateStatus(status) {
                document.getElementById('status').textContent = status;
            }
        }
        
        // Global client instance
        const client = new SFUClient();
        
        // UI functions
        async function testMicrophone() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    } 
                });
                client.log('Microphone test successful!');
                client.updateStatus('Microphone ready - you can now join a room');
                
                // Stop the test stream
                stream.getTracks().forEach(track => track.stop());
            } catch (error) {
                if (error.name === 'NotAllowedError') {
                    client.log('Microphone permission denied. Please allow access and try again.');
                    alert('Please click "Allow" when your browser asks for microphone permission.');
                } else {
                    client.log('Microphone test failed: ' + error.message);
                }
            }
        }
        
        function joinRoom() {
            const roomId = document.getElementById('roomId').value;
            const participantId = document.getElementById('participantId').value;
            client.joinRoom(roomId, participantId);
        }
        
        function leaveRoom() {
            client.leaveRoom();
        }
        
        function toggleMute() {
            client.toggleMute();
        }
        
        function getRoomStats() {
            client.getRoomStats();
        }
    </script>
</body>
</html>
